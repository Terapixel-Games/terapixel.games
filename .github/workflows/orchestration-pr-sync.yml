name: Orchestration PR Sync

on:
  pull_request:
    types: [opened, reopened, synchronize, ready_for_review, converted_to_draft, closed]

permissions:
  contents: read
  issues: write
  pull-requests: read

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Sync linked issue status from PR lifecycle
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            if (!pr) {
              core.info('No pull request payload found.');
              return;
            }

            const action = context.payload.action;
            let targetStatus = null;
            if (['opened', 'reopened', 'synchronize', 'converted_to_draft'].includes(action)) {
              targetStatus = 'status:in-progress';
            } else if (action === 'ready_for_review') {
              targetStatus = 'status:needs-review';
            } else if (action === 'closed') {
              targetStatus = pr.merged ? 'status:done' : 'status:ready';
            }

            if (!targetStatus) {
              core.info(`No status transition for action: ${action}`);
              return;
            }

            const bodyText = `${pr.title || ''}\n${pr.body || ''}`;
            const regex = /(?:close[sd]?|fix(?:e[sd])?|resolve[sd]?)\s+((?:[A-Za-z0-9_.-]+\/[A-Za-z0-9_.-]+)?#\d+)/gi;
            const refs = new Set();
            let match;
            while ((match = regex.exec(bodyText)) !== null) {
              refs.add(match[1]);
            }

            if (refs.size === 0) {
              core.info('No linked issues found in PR body.');
              return;
            }

            const statusLabels = [
              'status:triage', 'status:ready', 'status:in-progress',
              'status:needs-review', 'status:blocked', 'status:done'
            ];

            const parseRef = (ref) => {
              if (ref.includes('/')) {
                const [repoPart, numberPart] = ref.split('#');
                const [owner, repo] = repoPart.split('/');
                return { owner, repo, issue_number: Number(numberPart) };
              }
              return {
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: Number(ref.replace('#', ''))
              };
            };

            for (const ref of refs) {
              const target = parseRef(ref);
              if (!target.owner || !target.repo || !target.issue_number) {
                core.warning(`Skipping invalid issue reference: ${ref}`);
                continue;
              }

              let issue;
              try {
                const issueResponse = await github.rest.issues.get(target);
                issue = issueResponse.data;
              } catch (error) {
                core.warning(`Unable to load ${ref}: ${error.message}`);
                continue;
              }

              if (issue.pull_request) {
                core.info(`Skipping ${ref} because it is a pull request.`);
                continue;
              }

              const currentLabels = (issue.labels || []).map((l) => typeof l === 'string' ? l : l.name);
              const nextLabels = [...new Set([
                ...currentLabels.filter((l) => !statusLabels.includes(l)),
                targetStatus
              ])];

              const currentSorted = [...new Set(currentLabels)].sort();
              const nextSorted = [...new Set(nextLabels)].sort();
              const changed = JSON.stringify(currentSorted) !== JSON.stringify(nextSorted);

              if (changed) {
                await github.rest.issues.setLabels({ ...target, labels: nextSorted });
              }

              const marker = `<!-- orchestration:pr-sync:${pr.number} -->`;
              const stateText = pr.merged ? 'merged' : action;
              const commentBody = `${marker}

### Orchestration PR Sync
- PR: #${pr.number} (${pr.html_url})
- Event: \`${action}\`
- State: \`${stateText}\`
- Issue status set to: \`${targetStatus}\`
`;

              let existing = null;
              try {
                const comments = await github.paginate(github.rest.issues.listComments, {
                  owner: target.owner,
                  repo: target.repo,
                  issue_number: target.issue_number,
                  per_page: 100
                });
                existing = comments.find((c) => (c.body || '').includes(marker));
              } catch (error) {
                core.warning(`Unable to inspect comments for ${ref}: ${error.message}`);
              }

              if (existing) {
                await github.rest.issues.updateComment({
                  owner: target.owner,
                  repo: target.repo,
                  comment_id: existing.id,
                  body: commentBody
                });
              } else {
                await github.rest.issues.createComment({
                  owner: target.owner,
                  repo: target.repo,
                  issue_number: target.issue_number,
                  body: commentBody
                });
              }

              core.info(`Updated ${ref} -> ${targetStatus}`);
            }
