name: Orchestration PR Sync

on:
  pull_request:
    types: [opened, reopened, synchronize, ready_for_review, converted_to_draft, closed]

permissions:
  contents: read
  issues: write
  pull-requests: read

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Update linked issue status from PR lifecycle
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            if (!pr) return;

            const action = context.payload.action;
            let targetStatus = null;
            if (['opened', 'reopened', 'synchronize', 'converted_to_draft'].includes(action)) {
              targetStatus = 'status:in-progress';
            } else if (action === 'ready_for_review') {
              targetStatus = 'status:needs-review';
            } else if (action === 'closed') {
              targetStatus = pr.merged ? 'status:done' : 'status:ready';
            } else {
              return;
            }

            const text = (pr.title || '') + '\n' + (pr.body || '');
            const regex = /(?:close[sd]?|fix(?:e[sd])?|resolve[sd]?)\s+((?:[A-Za-z0-9_.-]+\/[A-Za-z0-9_.-]+)?#\d+)/gi;
            const refs = [];
            let match;
            while ((match = regex.exec(text)) !== null) refs.push(match[1]);
            if (refs.length === 0) return;

            const statusLabels = [
              'status:triage', 'status:ready', 'status:in-progress',
              'status:needs-review', 'status:blocked', 'status:done'
            ];

            const parseRef = (ref) => {
              if (ref.includes('/')) {
                const parts = ref.split('#');
                const repoParts = parts[0].split('/');
                return {
                  owner: repoParts[0],
                  repo: repoParts[1],
                  issue_number: Number(parts[1])
                };
              }
              return {
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: Number(ref.replace('#', ''))
              };
            };

            for (const ref of Array.from(new Set(refs))) {
              const target = parseRef(ref);
              if (!target.owner || !target.repo || !target.issue_number) continue;

              let issue;
              try {
                issue = (await github.rest.issues.get(target)).data;
              } catch {
                continue;
              }
              if (issue.pull_request) continue;

              const current = (issue.labels || []).map((l) => typeof l === 'string' ? l : l.name);
              const next = Array.from(new Set([
                ...current.filter((l) => !statusLabels.includes(l)),
                targetStatus
              ]));

              const curSorted = Array.from(new Set(current)).sort();
              const nextSorted = Array.from(new Set(next)).sort();
              if (JSON.stringify(curSorted) !== JSON.stringify(nextSorted)) {
                await github.rest.issues.setLabels({
                  owner: target.owner,
                  repo: target.repo,
                  issue_number: target.issue_number,
                  labels: nextSorted
                });
              }

              const marker = '<!-- orchestration:pr-sync:' + pr.number + ' -->';
              const lines = [
                marker,
                '',
                '### Orchestration PR Sync',
                '- PR: #' + pr.number + ' ' + pr.html_url,
                '- Event: ' + action,
                '- Status set: ' + targetStatus
              ];
              const body = lines.join('\n');

              const comments = await github.paginate(github.rest.issues.listComments, {
                owner: target.owner,
                repo: target.repo,
                issue_number: target.issue_number,
                per_page: 100
              });
              const existing = comments.find((c) => (c.body || '').includes(marker));

              if (existing) {
                await github.rest.issues.updateComment({
                  owner: target.owner,
                  repo: target.repo,
                  comment_id: existing.id,
                  body
                });
              } else {
                await github.rest.issues.createComment({
                  owner: target.owner,
                  repo: target.repo,
                  issue_number: target.issue_number,
                  body
                });
              }
            }
